1. 哪些寄存器保存函数的参数？如在`main`对`printf`的调用中，哪个寄存器保存13？

   RISC-V提供了8个寄存器用于传参，为`a0 - a7`，超过8个参数之后的参数通过栈传递。 在`main`调用`printf`时，13应该保存在寄存器`a2`中，由汇编代码可以看出（`li`指令，可以用来加载常量）：

   ```asm
    void main(void) {
        ...
        printf("%d %d\n", f(8)+1, 13);
        24: 4635                    li  a2,13
        ...
    }
   ```

2. `main`的汇编代码中对函数`f`的调用在哪里？对`g`的调用在哪里(提示：编译器可能会将函数内联）

   没有对`f`和`g`函数调用的代码，`g`函数被内联到`f`函数中，`f`函数被内联到`main`函数中。可以看到`main`中直接把`f(8) + 1`的值传递给了`a1`寄存器，没有对`f`函数进行调用。

   ```c
    void main(void) {
        ...
        printf("%d %d\n", f(8)+1, 13);
        24: 4635                    li  a2,13
        26: 45b1                    li  a1,12
        ...
    }
   ```

3. `printf`函数位于哪个地址？

   - `printf`函数位于的地址是0x630

   - 汇编代码如下所示：`auipc`指令将0x0左移20位，然后加到`pc`上，并将结果写入`ra`，这一行代码的开头，即为`pc`当前的值，即`pc = 0x30`。那么有`pc = 0x30 = ra`。然后通过`jalr`指令（`jalr`指令可以用来进行**函数跳转**），将`pc`设置为`ra`寄存器中的值加上1536这个偏移量，`ra + 1536 = 0x30 + 0x0600 = 0x0630`，然后无条件跳转到当前`pc`的位置，即`0x0630`，所以`printf`函数的地址在`0x0630`

     ```asm
        30:   00000097            auipc   ra,0x0 #设置ra高20位为0
        34:   600080e7            jalr    1536(ra) # 630  调用函数printf
     ```

4. 在`main`中`printf`的`jalr`之后的寄存器`ra`中有什么值？

   - 上面的`jalr`指令，不仅设置了`pc`的值用于函数跳转，还会将**下一条指令的地址**保存到寄存器`ra`（即`printf`调用返回`main`之后的地址）。由于指令是32位，所以应该将`ra`设置为当前`pc + 4`，所以`ra = pc + 4 = 34 + 4 = 0x38`

5. 运行以下代码，程序的输出是什么？

   这是将字节映射到字符的[ASCII码表](http://web.cs.mun.ca/~michael/c/ascii-table.html)。

   输出取决于RISC-V小端存储的事实。如果RISC-V是大端存储，为了得到相同的输出，你会把`i`设置成什么？是否需要将`57616`更改为其他值？

   ``` c
   unsigned int i = 0x00646c72;
   printf("H%x Wo%s", 57616, &i);
   ```

   答：

   由于RISC-V是小端序，对于`i`，其字节在地址中的存放顺序是`72 6c 64`，在ASCII码表中分别对应`r l d`，而数字57616转换成16进制的结果为 0x0000e110，所以上述代码的输出结果是`He110 World`。

   如果RISC-V是大端存储，而为了产生相同的输出，`i`需要改变，改变后的`i = 0x726c6400`；由于`%x`是得到参数的十六进制，所以不管是大端序还是小端序，对于固定的参数其十六进制都是不变的，所以57616不用改变。

6. 下面的代码中，`y=`之后将打印什么值？（提示：答案不是一个特定的值），为什么会这样？

   ```c
   printf("x=%d y=%d", 3);
   ```
   答：
   
   输出的是一个受调用前代码影响的**随机值**。`printf`尝试读取的参数数量比提供的参数多。第二个参数 `3` 会通过寄存器`a1`传递，而第三个参数对应的寄存器`a2`在调用前**不会被设置为任何具体的值**，而是**会包含调用发生前的任何已经在里面的值**，即会输出`a2`寄存器的值，但`a2`寄存器的值是不确定的，跟之前的其他代码调用有关。